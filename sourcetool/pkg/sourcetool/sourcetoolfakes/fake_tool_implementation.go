// Code generated by counterfeiter. DO NOT EDIT.
package sourcetoolfakes

import (
	"sync"

	"github.com/slsa-framework/slsa-source-poc/sourcetool/pkg/slsa"
	"github.com/slsa-framework/slsa-source-poc/sourcetool/pkg/sourcetool/options"
)

type FakeToolImplementation struct {
	CheckForksStub        func(*options.Options) error
	checkForksMutex       sync.RWMutex
	checkForksArgsForCall []struct {
		arg1 *options.Options
	}
	checkForksReturns struct {
		result1 error
	}
	checkForksReturnsOnCall map[int]struct {
		result1 error
	}
	CheckPolicyForkStub        func(*options.Options) error
	checkPolicyForkMutex       sync.RWMutex
	checkPolicyForkArgsForCall []struct {
		arg1 *options.Options
	}
	checkPolicyForkReturns struct {
		result1 error
	}
	checkPolicyForkReturnsOnCall map[int]struct {
		result1 error
	}
	CheckWorkflowForkStub        func(*options.Options) error
	checkWorkflowForkMutex       sync.RWMutex
	checkWorkflowForkArgsForCall []struct {
		arg1 *options.Options
	}
	checkWorkflowForkReturns struct {
		result1 error
	}
	checkWorkflowForkReturnsOnCall map[int]struct {
		result1 error
	}
	CreatePolicyPRStub        func(*options.Options) error
	createPolicyPRMutex       sync.RWMutex
	createPolicyPRArgsForCall []struct {
		arg1 *options.Options
	}
	createPolicyPRReturns struct {
		result1 error
	}
	createPolicyPRReturnsOnCall map[int]struct {
		result1 error
	}
	CreateRepoRulesetStub        func(*options.Options) error
	createRepoRulesetMutex       sync.RWMutex
	createRepoRulesetArgsForCall []struct {
		arg1 *options.Options
	}
	createRepoRulesetReturns struct {
		result1 error
	}
	createRepoRulesetReturnsOnCall map[int]struct {
		result1 error
	}
	CreateWorkflowPRStub        func(*options.Options) error
	createWorkflowPRMutex       sync.RWMutex
	createWorkflowPRArgsForCall []struct {
		arg1 *options.Options
	}
	createWorkflowPRReturns struct {
		result1 error
	}
	createWorkflowPRReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureDefaultsStub        func(*options.Options) error
	ensureDefaultsMutex       sync.RWMutex
	ensureDefaultsArgsForCall []struct {
		arg1 *options.Options
	}
	ensureDefaultsReturns struct {
		result1 error
	}
	ensureDefaultsReturnsOnCall map[int]struct {
		result1 error
	}
	GetActiveControlsStub        func(*options.Options) (slsa.Controls, error)
	getActiveControlsMutex       sync.RWMutex
	getActiveControlsArgsForCall []struct {
		arg1 *options.Options
	}
	getActiveControlsReturns struct {
		result1 slsa.Controls
		result2 error
	}
	getActiveControlsReturnsOnCall map[int]struct {
		result1 slsa.Controls
		result2 error
	}
	SearchPullRequestStub        func(*options.Options, string) (int, error)
	searchPullRequestMutex       sync.RWMutex
	searchPullRequestArgsForCall []struct {
		arg1 *options.Options
		arg2 string
	}
	searchPullRequestReturns struct {
		result1 int
		result2 error
	}
	searchPullRequestReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	VerifyOptionsForFullOnboardStub        func(*options.Options) error
	verifyOptionsForFullOnboardMutex       sync.RWMutex
	verifyOptionsForFullOnboardArgsForCall []struct {
		arg1 *options.Options
	}
	verifyOptionsForFullOnboardReturns struct {
		result1 error
	}
	verifyOptionsForFullOnboardReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeToolImplementation) CheckForks(arg1 *options.Options) error {
	fake.checkForksMutex.Lock()
	ret, specificReturn := fake.checkForksReturnsOnCall[len(fake.checkForksArgsForCall)]
	fake.checkForksArgsForCall = append(fake.checkForksArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.CheckForksStub
	fakeReturns := fake.checkForksReturns
	fake.recordInvocation("CheckForks", []interface{}{arg1})
	fake.checkForksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) CheckForksCallCount() int {
	fake.checkForksMutex.RLock()
	defer fake.checkForksMutex.RUnlock()
	return len(fake.checkForksArgsForCall)
}

func (fake *FakeToolImplementation) CheckForksCalls(stub func(*options.Options) error) {
	fake.checkForksMutex.Lock()
	defer fake.checkForksMutex.Unlock()
	fake.CheckForksStub = stub
}

func (fake *FakeToolImplementation) CheckForksArgsForCall(i int) *options.Options {
	fake.checkForksMutex.RLock()
	defer fake.checkForksMutex.RUnlock()
	argsForCall := fake.checkForksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) CheckForksReturns(result1 error) {
	fake.checkForksMutex.Lock()
	defer fake.checkForksMutex.Unlock()
	fake.CheckForksStub = nil
	fake.checkForksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CheckForksReturnsOnCall(i int, result1 error) {
	fake.checkForksMutex.Lock()
	defer fake.checkForksMutex.Unlock()
	fake.CheckForksStub = nil
	if fake.checkForksReturnsOnCall == nil {
		fake.checkForksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkForksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CheckPolicyFork(arg1 *options.Options) error {
	fake.checkPolicyForkMutex.Lock()
	ret, specificReturn := fake.checkPolicyForkReturnsOnCall[len(fake.checkPolicyForkArgsForCall)]
	fake.checkPolicyForkArgsForCall = append(fake.checkPolicyForkArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.CheckPolicyForkStub
	fakeReturns := fake.checkPolicyForkReturns
	fake.recordInvocation("CheckPolicyFork", []interface{}{arg1})
	fake.checkPolicyForkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) CheckPolicyForkCallCount() int {
	fake.checkPolicyForkMutex.RLock()
	defer fake.checkPolicyForkMutex.RUnlock()
	return len(fake.checkPolicyForkArgsForCall)
}

func (fake *FakeToolImplementation) CheckPolicyForkCalls(stub func(*options.Options) error) {
	fake.checkPolicyForkMutex.Lock()
	defer fake.checkPolicyForkMutex.Unlock()
	fake.CheckPolicyForkStub = stub
}

func (fake *FakeToolImplementation) CheckPolicyForkArgsForCall(i int) *options.Options {
	fake.checkPolicyForkMutex.RLock()
	defer fake.checkPolicyForkMutex.RUnlock()
	argsForCall := fake.checkPolicyForkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) CheckPolicyForkReturns(result1 error) {
	fake.checkPolicyForkMutex.Lock()
	defer fake.checkPolicyForkMutex.Unlock()
	fake.CheckPolicyForkStub = nil
	fake.checkPolicyForkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CheckPolicyForkReturnsOnCall(i int, result1 error) {
	fake.checkPolicyForkMutex.Lock()
	defer fake.checkPolicyForkMutex.Unlock()
	fake.CheckPolicyForkStub = nil
	if fake.checkPolicyForkReturnsOnCall == nil {
		fake.checkPolicyForkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkPolicyForkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CheckWorkflowFork(arg1 *options.Options) error {
	fake.checkWorkflowForkMutex.Lock()
	ret, specificReturn := fake.checkWorkflowForkReturnsOnCall[len(fake.checkWorkflowForkArgsForCall)]
	fake.checkWorkflowForkArgsForCall = append(fake.checkWorkflowForkArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.CheckWorkflowForkStub
	fakeReturns := fake.checkWorkflowForkReturns
	fake.recordInvocation("CheckWorkflowFork", []interface{}{arg1})
	fake.checkWorkflowForkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) CheckWorkflowForkCallCount() int {
	fake.checkWorkflowForkMutex.RLock()
	defer fake.checkWorkflowForkMutex.RUnlock()
	return len(fake.checkWorkflowForkArgsForCall)
}

func (fake *FakeToolImplementation) CheckWorkflowForkCalls(stub func(*options.Options) error) {
	fake.checkWorkflowForkMutex.Lock()
	defer fake.checkWorkflowForkMutex.Unlock()
	fake.CheckWorkflowForkStub = stub
}

func (fake *FakeToolImplementation) CheckWorkflowForkArgsForCall(i int) *options.Options {
	fake.checkWorkflowForkMutex.RLock()
	defer fake.checkWorkflowForkMutex.RUnlock()
	argsForCall := fake.checkWorkflowForkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) CheckWorkflowForkReturns(result1 error) {
	fake.checkWorkflowForkMutex.Lock()
	defer fake.checkWorkflowForkMutex.Unlock()
	fake.CheckWorkflowForkStub = nil
	fake.checkWorkflowForkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CheckWorkflowForkReturnsOnCall(i int, result1 error) {
	fake.checkWorkflowForkMutex.Lock()
	defer fake.checkWorkflowForkMutex.Unlock()
	fake.CheckWorkflowForkStub = nil
	if fake.checkWorkflowForkReturnsOnCall == nil {
		fake.checkWorkflowForkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkWorkflowForkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CreatePolicyPR(arg1 *options.Options) error {
	fake.createPolicyPRMutex.Lock()
	ret, specificReturn := fake.createPolicyPRReturnsOnCall[len(fake.createPolicyPRArgsForCall)]
	fake.createPolicyPRArgsForCall = append(fake.createPolicyPRArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.CreatePolicyPRStub
	fakeReturns := fake.createPolicyPRReturns
	fake.recordInvocation("CreatePolicyPR", []interface{}{arg1})
	fake.createPolicyPRMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) CreatePolicyPRCallCount() int {
	fake.createPolicyPRMutex.RLock()
	defer fake.createPolicyPRMutex.RUnlock()
	return len(fake.createPolicyPRArgsForCall)
}

func (fake *FakeToolImplementation) CreatePolicyPRCalls(stub func(*options.Options) error) {
	fake.createPolicyPRMutex.Lock()
	defer fake.createPolicyPRMutex.Unlock()
	fake.CreatePolicyPRStub = stub
}

func (fake *FakeToolImplementation) CreatePolicyPRArgsForCall(i int) *options.Options {
	fake.createPolicyPRMutex.RLock()
	defer fake.createPolicyPRMutex.RUnlock()
	argsForCall := fake.createPolicyPRArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) CreatePolicyPRReturns(result1 error) {
	fake.createPolicyPRMutex.Lock()
	defer fake.createPolicyPRMutex.Unlock()
	fake.CreatePolicyPRStub = nil
	fake.createPolicyPRReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CreatePolicyPRReturnsOnCall(i int, result1 error) {
	fake.createPolicyPRMutex.Lock()
	defer fake.createPolicyPRMutex.Unlock()
	fake.CreatePolicyPRStub = nil
	if fake.createPolicyPRReturnsOnCall == nil {
		fake.createPolicyPRReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createPolicyPRReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CreateRepoRuleset(arg1 *options.Options) error {
	fake.createRepoRulesetMutex.Lock()
	ret, specificReturn := fake.createRepoRulesetReturnsOnCall[len(fake.createRepoRulesetArgsForCall)]
	fake.createRepoRulesetArgsForCall = append(fake.createRepoRulesetArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.CreateRepoRulesetStub
	fakeReturns := fake.createRepoRulesetReturns
	fake.recordInvocation("CreateRepoRuleset", []interface{}{arg1})
	fake.createRepoRulesetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) CreateRepoRulesetCallCount() int {
	fake.createRepoRulesetMutex.RLock()
	defer fake.createRepoRulesetMutex.RUnlock()
	return len(fake.createRepoRulesetArgsForCall)
}

func (fake *FakeToolImplementation) CreateRepoRulesetCalls(stub func(*options.Options) error) {
	fake.createRepoRulesetMutex.Lock()
	defer fake.createRepoRulesetMutex.Unlock()
	fake.CreateRepoRulesetStub = stub
}

func (fake *FakeToolImplementation) CreateRepoRulesetArgsForCall(i int) *options.Options {
	fake.createRepoRulesetMutex.RLock()
	defer fake.createRepoRulesetMutex.RUnlock()
	argsForCall := fake.createRepoRulesetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) CreateRepoRulesetReturns(result1 error) {
	fake.createRepoRulesetMutex.Lock()
	defer fake.createRepoRulesetMutex.Unlock()
	fake.CreateRepoRulesetStub = nil
	fake.createRepoRulesetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CreateRepoRulesetReturnsOnCall(i int, result1 error) {
	fake.createRepoRulesetMutex.Lock()
	defer fake.createRepoRulesetMutex.Unlock()
	fake.CreateRepoRulesetStub = nil
	if fake.createRepoRulesetReturnsOnCall == nil {
		fake.createRepoRulesetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createRepoRulesetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CreateWorkflowPR(arg1 *options.Options) error {
	fake.createWorkflowPRMutex.Lock()
	ret, specificReturn := fake.createWorkflowPRReturnsOnCall[len(fake.createWorkflowPRArgsForCall)]
	fake.createWorkflowPRArgsForCall = append(fake.createWorkflowPRArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.CreateWorkflowPRStub
	fakeReturns := fake.createWorkflowPRReturns
	fake.recordInvocation("CreateWorkflowPR", []interface{}{arg1})
	fake.createWorkflowPRMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) CreateWorkflowPRCallCount() int {
	fake.createWorkflowPRMutex.RLock()
	defer fake.createWorkflowPRMutex.RUnlock()
	return len(fake.createWorkflowPRArgsForCall)
}

func (fake *FakeToolImplementation) CreateWorkflowPRCalls(stub func(*options.Options) error) {
	fake.createWorkflowPRMutex.Lock()
	defer fake.createWorkflowPRMutex.Unlock()
	fake.CreateWorkflowPRStub = stub
}

func (fake *FakeToolImplementation) CreateWorkflowPRArgsForCall(i int) *options.Options {
	fake.createWorkflowPRMutex.RLock()
	defer fake.createWorkflowPRMutex.RUnlock()
	argsForCall := fake.createWorkflowPRArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) CreateWorkflowPRReturns(result1 error) {
	fake.createWorkflowPRMutex.Lock()
	defer fake.createWorkflowPRMutex.Unlock()
	fake.CreateWorkflowPRStub = nil
	fake.createWorkflowPRReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) CreateWorkflowPRReturnsOnCall(i int, result1 error) {
	fake.createWorkflowPRMutex.Lock()
	defer fake.createWorkflowPRMutex.Unlock()
	fake.CreateWorkflowPRStub = nil
	if fake.createWorkflowPRReturnsOnCall == nil {
		fake.createWorkflowPRReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createWorkflowPRReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) EnsureDefaults(arg1 *options.Options) error {
	fake.ensureDefaultsMutex.Lock()
	ret, specificReturn := fake.ensureDefaultsReturnsOnCall[len(fake.ensureDefaultsArgsForCall)]
	fake.ensureDefaultsArgsForCall = append(fake.ensureDefaultsArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.EnsureDefaultsStub
	fakeReturns := fake.ensureDefaultsReturns
	fake.recordInvocation("EnsureDefaults", []interface{}{arg1})
	fake.ensureDefaultsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) EnsureDefaultsCallCount() int {
	fake.ensureDefaultsMutex.RLock()
	defer fake.ensureDefaultsMutex.RUnlock()
	return len(fake.ensureDefaultsArgsForCall)
}

func (fake *FakeToolImplementation) EnsureDefaultsCalls(stub func(*options.Options) error) {
	fake.ensureDefaultsMutex.Lock()
	defer fake.ensureDefaultsMutex.Unlock()
	fake.EnsureDefaultsStub = stub
}

func (fake *FakeToolImplementation) EnsureDefaultsArgsForCall(i int) *options.Options {
	fake.ensureDefaultsMutex.RLock()
	defer fake.ensureDefaultsMutex.RUnlock()
	argsForCall := fake.ensureDefaultsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) EnsureDefaultsReturns(result1 error) {
	fake.ensureDefaultsMutex.Lock()
	defer fake.ensureDefaultsMutex.Unlock()
	fake.EnsureDefaultsStub = nil
	fake.ensureDefaultsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) EnsureDefaultsReturnsOnCall(i int, result1 error) {
	fake.ensureDefaultsMutex.Lock()
	defer fake.ensureDefaultsMutex.Unlock()
	fake.EnsureDefaultsStub = nil
	if fake.ensureDefaultsReturnsOnCall == nil {
		fake.ensureDefaultsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureDefaultsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) GetActiveControls(arg1 *options.Options) (slsa.Controls, error) {
	fake.getActiveControlsMutex.Lock()
	ret, specificReturn := fake.getActiveControlsReturnsOnCall[len(fake.getActiveControlsArgsForCall)]
	fake.getActiveControlsArgsForCall = append(fake.getActiveControlsArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.GetActiveControlsStub
	fakeReturns := fake.getActiveControlsReturns
	fake.recordInvocation("GetActiveControls", []interface{}{arg1})
	fake.getActiveControlsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolImplementation) GetActiveControlsCallCount() int {
	fake.getActiveControlsMutex.RLock()
	defer fake.getActiveControlsMutex.RUnlock()
	return len(fake.getActiveControlsArgsForCall)
}

func (fake *FakeToolImplementation) GetActiveControlsCalls(stub func(*options.Options) (slsa.Controls, error)) {
	fake.getActiveControlsMutex.Lock()
	defer fake.getActiveControlsMutex.Unlock()
	fake.GetActiveControlsStub = stub
}

func (fake *FakeToolImplementation) GetActiveControlsArgsForCall(i int) *options.Options {
	fake.getActiveControlsMutex.RLock()
	defer fake.getActiveControlsMutex.RUnlock()
	argsForCall := fake.getActiveControlsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) GetActiveControlsReturns(result1 slsa.Controls, result2 error) {
	fake.getActiveControlsMutex.Lock()
	defer fake.getActiveControlsMutex.Unlock()
	fake.GetActiveControlsStub = nil
	fake.getActiveControlsReturns = struct {
		result1 slsa.Controls
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) GetActiveControlsReturnsOnCall(i int, result1 slsa.Controls, result2 error) {
	fake.getActiveControlsMutex.Lock()
	defer fake.getActiveControlsMutex.Unlock()
	fake.GetActiveControlsStub = nil
	if fake.getActiveControlsReturnsOnCall == nil {
		fake.getActiveControlsReturnsOnCall = make(map[int]struct {
			result1 slsa.Controls
			result2 error
		})
	}
	fake.getActiveControlsReturnsOnCall[i] = struct {
		result1 slsa.Controls
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) SearchPullRequest(arg1 *options.Options, arg2 string) (int, error) {
	fake.searchPullRequestMutex.Lock()
	ret, specificReturn := fake.searchPullRequestReturnsOnCall[len(fake.searchPullRequestArgsForCall)]
	fake.searchPullRequestArgsForCall = append(fake.searchPullRequestArgsForCall, struct {
		arg1 *options.Options
		arg2 string
	}{arg1, arg2})
	stub := fake.SearchPullRequestStub
	fakeReturns := fake.searchPullRequestReturns
	fake.recordInvocation("SearchPullRequest", []interface{}{arg1, arg2})
	fake.searchPullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolImplementation) SearchPullRequestCallCount() int {
	fake.searchPullRequestMutex.RLock()
	defer fake.searchPullRequestMutex.RUnlock()
	return len(fake.searchPullRequestArgsForCall)
}

func (fake *FakeToolImplementation) SearchPullRequestCalls(stub func(*options.Options, string) (int, error)) {
	fake.searchPullRequestMutex.Lock()
	defer fake.searchPullRequestMutex.Unlock()
	fake.SearchPullRequestStub = stub
}

func (fake *FakeToolImplementation) SearchPullRequestArgsForCall(i int) (*options.Options, string) {
	fake.searchPullRequestMutex.RLock()
	defer fake.searchPullRequestMutex.RUnlock()
	argsForCall := fake.searchPullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeToolImplementation) SearchPullRequestReturns(result1 int, result2 error) {
	fake.searchPullRequestMutex.Lock()
	defer fake.searchPullRequestMutex.Unlock()
	fake.SearchPullRequestStub = nil
	fake.searchPullRequestReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) SearchPullRequestReturnsOnCall(i int, result1 int, result2 error) {
	fake.searchPullRequestMutex.Lock()
	defer fake.searchPullRequestMutex.Unlock()
	fake.SearchPullRequestStub = nil
	if fake.searchPullRequestReturnsOnCall == nil {
		fake.searchPullRequestReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.searchPullRequestReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboard(arg1 *options.Options) error {
	fake.verifyOptionsForFullOnboardMutex.Lock()
	ret, specificReturn := fake.verifyOptionsForFullOnboardReturnsOnCall[len(fake.verifyOptionsForFullOnboardArgsForCall)]
	fake.verifyOptionsForFullOnboardArgsForCall = append(fake.verifyOptionsForFullOnboardArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.VerifyOptionsForFullOnboardStub
	fakeReturns := fake.verifyOptionsForFullOnboardReturns
	fake.recordInvocation("VerifyOptionsForFullOnboard", []interface{}{arg1})
	fake.verifyOptionsForFullOnboardMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboardCallCount() int {
	fake.verifyOptionsForFullOnboardMutex.RLock()
	defer fake.verifyOptionsForFullOnboardMutex.RUnlock()
	return len(fake.verifyOptionsForFullOnboardArgsForCall)
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboardCalls(stub func(*options.Options) error) {
	fake.verifyOptionsForFullOnboardMutex.Lock()
	defer fake.verifyOptionsForFullOnboardMutex.Unlock()
	fake.VerifyOptionsForFullOnboardStub = stub
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboardArgsForCall(i int) *options.Options {
	fake.verifyOptionsForFullOnboardMutex.RLock()
	defer fake.verifyOptionsForFullOnboardMutex.RUnlock()
	argsForCall := fake.verifyOptionsForFullOnboardArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboardReturns(result1 error) {
	fake.verifyOptionsForFullOnboardMutex.Lock()
	defer fake.verifyOptionsForFullOnboardMutex.Unlock()
	fake.VerifyOptionsForFullOnboardStub = nil
	fake.verifyOptionsForFullOnboardReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) VerifyOptionsForFullOnboardReturnsOnCall(i int, result1 error) {
	fake.verifyOptionsForFullOnboardMutex.Lock()
	defer fake.verifyOptionsForFullOnboardMutex.Unlock()
	fake.VerifyOptionsForFullOnboardStub = nil
	if fake.verifyOptionsForFullOnboardReturnsOnCall == nil {
		fake.verifyOptionsForFullOnboardReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyOptionsForFullOnboardReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeToolImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
